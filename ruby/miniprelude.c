/* -*-c-*-
 THIS FILE WAS AUTOGENERATED BY template/prelude.c.tmpl. DO NOT EDIT.

 sources: ./ast, ./gc, ./io, ./pack, ./trace_point, ./warning, ./prelude, ./gem_prelude
*/
#include "ruby/ruby.h"
#include "internal.h"
#include "vm_core.h"
#include "iseq.h"


static const char prelude_name0[] = "<internal:ast>";
static const struct {
    char L0[505]; /* 1..104 */
    char L104[361]; /* 105..145 */
} prelude_code0 = {
#line 1 "ast.rb"
"\n"/* for ast.c */
"\n"
"class RubyVM\n"
"\n"
"\n"/* AbstractSyntaxTree provides methods to parse Ruby code into */
"\n"/* abstract syntax trees. The nodes in the tree */
"\n"/* are instances of RubyVM::AbstractSyntaxTree::Node. */
"\n"/*  */
"\n"/* This class is MRI specific as it exposes implementation details */
"\n"/* of the MRI abstract syntax tree. */
"\n"/*  */
"\n"/* This class is experimental and its API is not stable, therefore it might */
"\n"/* change without notice. As examples, the order of children nodes is not */
"\n"/* guaranteed, the number of children nodes might change, there is no way to */
"\n"/* access children nodes by name, etc. */
"\n"/*  */
"\n"/* If you are looking for a stable API or an API working under multiple Ruby */
"\n"/* implementations, consider using the _parser_ gem or Ripper. If you would */
"\n"/* like to make RubyVM::AbstractSyntaxTree stable, please join the discussion */
"\n"/* at https://bugs.ruby-lang.org/issues/14844. */
"\n"/*  */
"  module AbstractSyntaxTree\n"
"\n"
"\n"/*  call-seq: */
"\n"/*     RubyVM::AbstractSyntaxTree.parse(string) -> RubyVM::AbstractSyntaxTree::Node */
"\n"/*  */
"\n"/*  Parses the given _string_ into an abstract syntax tree, */
"\n"/*  returning the root node of that tree. */
"\n"/*  */
"\n"/*  SyntaxError is raised if the given _string_ is invalid syntax. */
"\n"/*  */
"\n"/*    RubyVM::AbstractSyntaxTree.parse(\"x = 1 + 2\") */
"\n"/*    # => #<RubyVM::AbstractSyntaxTree::Node:SCOPE@1:0-1:9> */
"    def self.parse string\n"
"      __builtin_ast_s_parse string\n"
"    end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*     RubyVM::AbstractSyntaxTree.parse_file(pathname) -> RubyVM::AbstractSyntaxTree::Node */
"\n"/*  */
"\n"/*   Reads the file from _pathname_, then parses it like ::parse, */
"\n"/*   returning the root node of the abstract syntax tree. */
"\n"/*  */
"\n"/*   SyntaxError is raised if _pathname_'s contents are not */
"\n"/*   valid Ruby syntax. */
"\n"/*  */
"\n"/*     RubyVM::AbstractSyntaxTree.parse_file(\"my-app/app.rb\") */
"\n"/*     # => #<RubyVM::AbstractSyntaxTree::Node:SCOPE@1:0-31:3> */
"    def self.parse_file pathname\n"
"      __builtin_ast_s_parse_file pathname\n"
"    end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*     RubyVM::AbstractSyntaxTree.of(proc)   -> RubyVM::AbstractSyntaxTree::Node */
"\n"/*     RubyVM::AbstractSyntaxTree.of(method) -> RubyVM::AbstractSyntaxTree::Node */
"\n"/*  */
"\n"/*   Returns AST nodes of the given _proc_ or _method_. */
"\n"/*  */
"\n"/*     RubyVM::AbstractSyntaxTree.of(proc {1 + 2}) */
"\n"/*     # => #<RubyVM::AbstractSyntaxTree::Node:SCOPE@1:35-1:42> */
"\n"/*  */
"\n"/*     def hello */
"\n"/*       puts \"hello, world\" */
"\n"/*     end */
"\n"/*  */
"\n"/*     RubyVM::AbstractSyntaxTree.of(method(:hello)) */
"\n"/*     # => #<RubyVM::AbstractSyntaxTree::Node:SCOPE@1:0-3:3> */
"    def self.of body\n"
"      __builtin_ast_s_of body\n"
"    end\n"
"\n"
"\n"/* RubyVM::AbstractSyntaxTree::Node instances are created by parse methods in */
"\n"/* RubyVM::AbstractSyntaxTree. */
"\n"/*  */
"\n"/* This class is MRI specific. */
"\n"/*  */
"    class Node\n"
"\n"
"\n"/*  call-seq: */
"\n"/*     node.type -> symbol */
"\n"/*  */
"\n"/*  Returns the type of this node as a symbol. */
"\n"/*  */
"\n"/*    root = RubyVM::AbstractSyntaxTree.parse(\"x = 1 + 2\") */
"\n"/*    root.type # => :SCOPE */
"\n"/*    call = root.children[2] */
"\n"/*    call.type # => :OPCALL */
"      def type\n"
"        __builtin_ast_node_type\n"
"      end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*     node.first_lineno -> integer */
"\n"/*  */
"\n"/*  The line number in the source code where this AST's text began. */
"      def first_lineno\n"
"        __builtin_ast_node_first_lineno\n"
"      end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*     node.first_column -> integer */
"\n"/*  */
"\n"/*  The column number in the source code where this AST's text began. */
"      def first_column\n"
,
#line 105 "ast.rb"
"        __builtin_ast_node_first_column\n"
"      end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*     node.last_lineno -> integer */
"\n"/*  */
"\n"/*  The line number in the source code where this AST's text ended. */
"      def last_lineno\n"
"        __builtin_ast_node_last_lineno\n"
"      end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*     node.last_column -> integer */
"\n"/*  */
"\n"/*  The column number in the source code where this AST's text ended. */
"      def last_column\n"
"        __builtin_ast_node_last_column\n"
"      end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*     node.children -> array */
"\n"/*  */
"\n"/*  Returns AST nodes under this one.  Each kind of node */
"\n"/*  has different children, depending on what kind of node it is. */
"\n"/*  */
"\n"/*  The returned array may contain other nodes or <code>nil</code>. */
"      def children\n"
"        __builtin_ast_node_children\n"
"      end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*     node.inspect -> string */
"\n"/*  */
"\n"/*  Returns debugging information about this node as a string. */
"      def inspect\n"
"        __builtin_ast_node_inspect\n"
"      end\n"
"    end\n"
"  end\n"
"end\n"
#line 165 "miniprelude.c"
};

static const char prelude_name1[] = "<internal:gc>";
static const struct {
    char L0[506]; /* 1..71 */
    char L71[463]; /* 72..163 */
    char L163[204]; /* 164..170 */
} prelude_code1 = {
#line 1 "gc.rb"
"\n"/* for gc.c */
"\n"
"\n"/*  The GC module provides an interface to Ruby's mark and */
"\n"/*  sweep garbage collection mechanism. */
"\n"/*  */
"\n"/*  Some of the underlying methods are also available via the ObjectSpace */
"\n"/*  module. */
"\n"/*  */
"\n"/*  You may obtain information about the operation of the GC through */
"\n"/*  GC::Profiler. */
"module GC\n"
"\n"
"\n"/*  call-seq: */
"\n"/*     GC.start                     -> nil */
"\n"/*     ObjectSpace.garbage_collect  -> nil */
"\n"/*     include GC; garbage_collect  -> nil */
"\n"/*     GC.start(full_mark: true, immediate_sweep: true)           -> nil */
"\n"/*     ObjectSpace.garbage_collect(full_mark: true, immediate_sweep: true) -> nil */
"\n"/*     include GC; garbage_collect(full_mark: true, immediate_sweep: true) -> nil */
"\n"/*  */
"\n"/*  Initiates garbage collection, even if manually disabled. */
"\n"/*  */
"\n"/*  This method is defined with keyword arguments that default to true: */
"\n"/*  */
"\n"/*     def GC.start(full_mark: true, immediate_sweep: true); end */
"\n"/*  */
"\n"/*  Use full_mark: false to perform a minor GC. */
"\n"/*  Use immediate_sweep: false to defer sweeping (use lazy sweep). */
"\n"/*  */
"\n"/*  Note: These keyword arguments are implementation and version dependent. They */
"\n"/*  are not guaranteed to be future-compatible, and may be ignored if the */
"\n"/*  underlying implementation does not support them. */
"  def self.start full_mark: true, immediate_mark: true, immediate_sweep: true\n"
"    __builtin_gc_start_internal full_mark, immediate_mark, immediate_sweep\n"
"  end\n"
"\n"
"  def garbage_collect full_mark: true, immediate_mark: true, immediate_sweep: true\n"
"    __builtin_gc_start_internal full_mark, immediate_mark, immediate_sweep\n"
"  end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*     GC.enable    -> true or false */
"\n"/*  */
"\n"/*  Enables garbage collection, returning +true+ if garbage */
"\n"/*  collection was previously disabled. */
"\n"/*  */
"\n"/*     GC.disable   #=> false */
"\n"/*     GC.enable    #=> true */
"\n"/*     GC.enable    #=> false */
"\n"/*  */
"  def self.enable\n"
"    __builtin_gc_enable\n"
"  end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*     GC.disable    -> true or false */
"\n"/*  */
"\n"/*  Disables garbage collection, returning +true+ if garbage */
"\n"/*  collection was already disabled. */
"\n"/*  */
"\n"/*     GC.disable   #=> false */
"\n"/*     GC.disable   #=> true */
"  def self.disable\n"
"    __builtin_gc_disable\n"
"  end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*    GC.stress\011    -> integer, true or false */
"\n"/*  */
"\n"/*  Returns current status of GC stress mode. */
"  def self.stress\n"
,
#line 72 "gc.rb"
"    __builtin_gc_stress_get\n"
"  end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*    GC.stress = flag          -> flag */
"\n"/*  */
"\n"/*  Updates the GC stress mode. */
"\n"/*  */
"\n"/*  When stress mode is enabled, the GC is invoked at every GC opportunity: */
"\n"/*  all memory and object allocations. */
"\n"/*  */
"\n"/*  Enabling stress mode will degrade performance, it is only for debugging. */
"\n"/*  */
"\n"/*  flag can be true, false, or an integer bit-ORed following flags. */
"\n"/*    0x01:: no major GC */
"\n"/*    0x02:: no immediate sweep */
"\n"/*    0x04:: full mark after malloc/calloc/realloc */
"  def self.stress=(flag)\n"
"    __builtin_gc_stress_set_m flag\n"
"  end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*     GC.count -> Integer */
"\n"/*  */
"\n"/*  The number of times GC occurred. */
"\n"/*  */
"\n"/*  It returns the number of times GC occurred since the process started. */
"  def self.count\n"
"    __builtin_gc_count\n"
"  end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*     GC.stat -> Hash */
"\n"/*     GC.stat(hash) -> hash */
"\n"/*     GC.stat(:key) -> Numeric */
"\n"/*  */
"\n"/*  Returns a Hash containing information about the GC. */
"\n"/*  */
"\n"/*  The hash includes information about internal statistics about GC such as: */
"\n"/*  */
"\n"/*      { */
"\n"/*          :count=>0, */
"\n"/*          :heap_allocated_pages=>24, */
"\n"/*          :heap_sorted_length=>24, */
"\n"/*          :heap_allocatable_pages=>0, */
"\n"/*          :heap_available_slots=>9783, */
"\n"/*          :heap_live_slots=>7713, */
"\n"/*          :heap_free_slots=>2070, */
"\n"/*          :heap_final_slots=>0, */
"\n"/*          :heap_marked_slots=>0, */
"\n"/*          :heap_eden_pages=>24, */
"\n"/*          :heap_tomb_pages=>0, */
"\n"/*          :total_allocated_pages=>24, */
"\n"/*          :total_freed_pages=>0, */
"\n"/*          :total_allocated_objects=>7796, */
"\n"/*          :total_freed_objects=>83, */
"\n"/*          :malloc_increase_bytes=>2389312, */
"\n"/*          :malloc_increase_bytes_limit=>16777216, */
"\n"/*          :minor_gc_count=>0, */
"\n"/*          :major_gc_count=>0, */
"\n"/*          :remembered_wb_unprotected_objects=>0, */
"\n"/*          :remembered_wb_unprotected_objects_limit=>0, */
"\n"/*          :old_objects=>0, */
"\n"/*          :old_objects_limit=>0, */
"\n"/*          :oldmalloc_increase_bytes=>2389760, */
"\n"/*          :oldmalloc_increase_bytes_limit=>16777216 */
"\n"/*      } */
"\n"/*  */
"\n"/*  The contents of the hash are implementation specific and may be changed in */
"\n"/*  the future. */
"\n"/*  */
"\n"/*  This method is only expected to work on C Ruby. */
"  def self.stat hash_or_key = nil\n"
"    __builtin_gc_stat hash_or_key\n"
"  end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*     GC.latest_gc_info -> {:gc_by=>:newobj} */
"\n"/*     GC.latest_gc_info(hash) -> hash */
"\n"/*     GC.latest_gc_info(:major_by) -> :malloc */
"\n"/*  */
"\n"/*  Returns information about the most recent garbage collection. */
"  def self.latest_gc_info hash_or_key = nil\n"
"    __builtin_gc_latest_gc_info hash_or_key\n"
"  end\n"
"\n"
"  def self.compact\n"
"    __builtin_rb_gc_compact\n"
"  end\n"
"end\n"
"\n"
"module ObjectSpace\n"
,
#line 164 "gc.rb"
"  def garbage_collect full_mark: true, immediate_mark: true, immediate_sweep: true\n"
"    __builtin_gc_start_internal full_mark, immediate_mark, immediate_sweep\n"
"  end\n"
"\n"
"  module_function :garbage_collect\n"
"end\n"
#line 348 "miniprelude.c"
};

static const char prelude_name2[] = "<internal:io>";
static const struct {
    char L0[336]; /* 1..124 */
} prelude_code2 = {
#line 1 "io.rb"
"class IO\n"
"\n"/* other IO methods are defined in io.c */
"\n"
"\n"/* call-seq: */
"\n"/*    ios.read_nonblock(maxlen [, options])              -> string */
"\n"/*    ios.read_nonblock(maxlen, outbuf [, options])      -> outbuf */
"\n"/*  */
"\n"/* Reads at most <i>maxlen</i> bytes from <em>ios</em> using */
"\n"/* the read(2) system call after O_NONBLOCK is set for */
"\n"/* the underlying file descriptor. */
"\n"/*  */
"\n"/* If the optional <i>outbuf</i> argument is present, */
"\n"/* it must reference a String, which will receive the data. */
"\n"/* The <i>outbuf</i> will contain only the received data after the method call */
"\n"/* even if it is not empty at the beginning. */
"\n"/*  */
"\n"/* read_nonblock just calls the read(2) system call. */
"\n"/* It causes all errors the read(2) system call causes: Errno::EWOULDBLOCK, Errno::EINTR, etc. */
"\n"/* The caller should care such errors. */
"\n"/*  */
"\n"/* If the exception is Errno::EWOULDBLOCK or Errno::EAGAIN, */
"\n"/* it is extended by IO::WaitReadable. */
"\n"/* So IO::WaitReadable can be used to rescue the exceptions for retrying */
"\n"/* read_nonblock. */
"\n"/*  */
"\n"/* read_nonblock causes EOFError on EOF. */
"\n"/*  */
"\n"/* On some platforms, such as Windows, non-blocking mode is not supported */
"\n"/* on IO objects other than sockets. In such cases, Errno::EBADF will */
"\n"/* be raised. */
"\n"/*  */
"\n"/* If the read byte buffer is not empty, */
"\n"/* read_nonblock reads from the buffer like readpartial. */
"\n"/* In this case, the read(2) system call is not called. */
"\n"/*  */
"\n"/* When read_nonblock raises an exception kind of IO::WaitReadable, */
"\n"/* read_nonblock should not be called */
"\n"/* until io is readable for avoiding busy loop. */
"\n"/* This can be done as follows. */
"\n"/*  */
"\n"/*   # emulates blocking read (readpartial). */
"\n"/*   begin */
"\n"/*     result = io.read_nonblock(maxlen) */
"\n"/*   rescue IO::WaitReadable */
"\n"/*     IO.select([io]) */
"\n"/*     retry */
"\n"/*   end */
"\n"/*  */
"\n"/* Although IO#read_nonblock doesn't raise IO::WaitWritable. */
"\n"/* OpenSSL::Buffering#read_nonblock can raise IO::WaitWritable. */
"\n"/* If IO and SSL should be used polymorphically, */
"\n"/* IO::WaitWritable should be rescued too. */
"\n"/* See the document of OpenSSL::Buffering#read_nonblock for sample code. */
"\n"/*  */
"\n"/* Note that this method is identical to readpartial */
"\n"/* except the non-blocking flag is set. */
"\n"/*  */
"\n"/* By specifying a keyword argument _exception_ to +false+, you can indicate */
"\n"/* that read_nonblock should not raise an IO::WaitReadable exception, but */
"\n"/* return the symbol +:wait_readable+ instead. At EOF, it will return nil */
"\n"/* instead of raising EOFError. */
"  def read_nonblock(len, buf = nil, exception: true)\n"
"    __builtin_io_read_nonblock(len, buf, exception)\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*    ios.write_nonblock(string)   -> integer */
"\n"/*    ios.write_nonblock(string [, options])   -> integer */
"\n"/*  */
"\n"/* Writes the given string to <em>ios</em> using */
"\n"/* the write(2) system call after O_NONBLOCK is set for */
"\n"/* the underlying file descriptor. */
"\n"/*  */
"\n"/* It returns the number of bytes written. */
"\n"/*  */
"\n"/* write_nonblock just calls the write(2) system call. */
"\n"/* It causes all errors the write(2) system call causes: Errno::EWOULDBLOCK, Errno::EINTR, etc. */
"\n"/* The result may also be smaller than string.length (partial write). */
"\n"/* The caller should care such errors and partial write. */
"\n"/*  */
"\n"/* If the exception is Errno::EWOULDBLOCK or Errno::EAGAIN, */
"\n"/* it is extended by IO::WaitWritable. */
"\n"/* So IO::WaitWritable can be used to rescue the exceptions for retrying write_nonblock. */
"\n"/*  */
"\n"/*   # Creates a pipe. */
"\n"/*   r, w = IO.pipe */
"\n"/*  */
"\n"/*   # write_nonblock writes only 65536 bytes and return 65536. */
"\n"/*   # (The pipe size is 65536 bytes on this environment.) */
"\n"/*   s = \"a\" * 100000 */
"\n"/*   p w.write_nonblock(s)     #=> 65536 */
"\n"/*  */
"\n"/*   # write_nonblock cannot write a byte and raise EWOULDBLOCK (EAGAIN). */
"\n"/*   p w.write_nonblock(\"b\")   # Resource temporarily unavailable (Errno::EAGAIN) */
"\n"/*  */
"\n"/* If the write buffer is not empty, it is flushed at first. */
"\n"/*  */
"\n"/* When write_nonblock raises an exception kind of IO::WaitWritable, */
"\n"/* write_nonblock should not be called */
"\n"/* until io is writable for avoiding busy loop. */
"\n"/* This can be done as follows. */
"\n"/*  */
"\n"/*   begin */
"\n"/*     result = io.write_nonblock(string) */
"\n"/*   rescue IO::WaitWritable, Errno::EINTR */
"\n"/*     IO.select(nil, [io]) */
"\n"/*     retry */
"\n"/*   end */
"\n"/*  */
"\n"/* Note that this doesn't guarantee to write all data in string. */
"\n"/* The length written is reported as result and it should be checked later. */
"\n"/*  */
"\n"/* On some platforms such as Windows, write_nonblock is not supported */
"\n"/* according to the kind of the IO object. */
"\n"/* In such cases, write_nonblock raises <code>Errno::EBADF</code>. */
"\n"/*  */
"\n"/* By specifying a keyword argument _exception_ to +false+, you can indicate */
"\n"/* that write_nonblock should not raise an IO::WaitWritable exception, but */
"\n"/* return the symbol +:wait_writable+ instead. */
"  def write_nonblock(buf, exception: true)\n"
"    __builtin_io_write_nonblock(buf, exception)\n"
"  end\n"
"end\n"
#line 479 "miniprelude.c"
};

static const char prelude_name3[] = "<internal:pack>";
static const struct {
    char L0[487]; /* 1..284 */
} prelude_code3 = {
#line 1 "pack.rb"
"\n"/* for pack.c */
"\n"
"class Array\n"
"\n"/*  call-seq: */
"\n"/*     arr.pack( aTemplateString ) -> aBinaryString */
"\n"/*     arr.pack( aTemplateString, buffer: aBufferString ) -> aBufferString */
"\n"/*  */
"\n"/*  Packs the contents of <i>arr</i> into a binary sequence according to */
"\n"/*  the directives in <i>aTemplateString</i> (see the table below) */
"\n"/*  Directives ``A,'' ``a,'' and ``Z'' may be followed by a count, */
"\n"/*  which gives the width of the resulting field. The remaining */
"\n"/*  directives also may take a count, indicating the number of array */
"\n"/*  elements to convert. If the count is an asterisk */
"\n"/*  (``<code>*</code>''), all remaining array elements will be */
"\n"/*  converted. Any of the directives ``<code>sSiIlL</code>'' may be */
"\n"/*  followed by an underscore (``<code>_</code>'') or */
"\n"/*  exclamation mark (``<code>!</code>'') to use the underlying */
"\n"/*  platform's native size for the specified type; otherwise, they use a */
"\n"/*  platform-independent size. Spaces are ignored in the template */
"\n"/*  string. See also String#unpack. */
"\n"/*  */
"\n"/*     a = [ \"a\", \"b\", \"c\" ] */
"\n"/*     n = [ 65, 66, 67 ] */
"\n"/*     a.pack(\"A3A3A3\")   #=> \"a  b  c  \" */
"\n"/*     a.pack(\"a3a3a3\")   #=> \"a\\000\\000b\\000\\000c\\000\\000\" */
"\n"/*     n.pack(\"ccc\")      #=> \"ABC\" */
"\n"/*  */
"\n"/*  If <i>aBufferString</i> is specified and its capacity is enough, */
"\n"/*  +pack+ uses it as the buffer and returns it. */
"\n"/*  When the offset is specified by the beginning of <i>aTemplateString</i>, */
"\n"/*  the result is filled after the offset. */
"\n"/*  If original contents of <i>aBufferString</i> exists and it's longer than */
"\n"/*  the offset, the rest of <i>offsetOfBuffer</i> are overwritten by the result. */
"\n"/*  If it's shorter, the gap is filled with ``<code>\\0</code>''. */
"\n"/*  */
"\n"/*  Note that ``buffer:'' option does not guarantee not to allocate memory */
"\n"/*  in +pack+.  If the capacity of <i>aBufferString</i> is not enough, */
"\n"/*  +pack+ allocates memory. */
"\n"/*  */
"\n"/*  Directives for +pack+. */
"\n"/*  */
"\n"/*   Integer       | Array   | */
"\n"/*   Directive     | Element | Meaning */
"\n"/*   ---------------------------------------------------------------------------- */
"\n"/*   C             | Integer | 8-bit unsigned (unsigned char) */
"\n"/*   S             | Integer | 16-bit unsigned, native endian (uint16_t) */
"\n"/*   L             | Integer | 32-bit unsigned, native endian (uint32_t) */
"\n"/*   Q             | Integer | 64-bit unsigned, native endian (uint64_t) */
"\n"/*   J             | Integer | pointer width unsigned, native endian (uintptr_t) */
"\n"/*                 |         | (J is available since Ruby 2.3.) */
"\n"/*                 |         | */
"\n"/*   c             | Integer | 8-bit signed (signed char) */
"\n"/*   s             | Integer | 16-bit signed, native endian (int16_t) */
"\n"/*   l             | Integer | 32-bit signed, native endian (int32_t) */
"\n"/*   q             | Integer | 64-bit signed, native endian (int64_t) */
"\n"/*   j             | Integer | pointer width signed, native endian (intptr_t) */
"\n"/*                 |         | (j is available since Ruby 2.3.) */
"\n"/*                 |         | */
"\n"/*   S_ S!         | Integer | unsigned short, native endian */
"\n"/*   I I_ I!       | Integer | unsigned int, native endian */
"\n"/*   L_ L!         | Integer | unsigned long, native endian */
"\n"/*   Q_ Q!         | Integer | unsigned long long, native endian (ArgumentError */
"\n"/*                 |         | if the platform has no long long type.) */
"\n"/*                 |         | (Q_ and Q! is available since Ruby 2.1.) */
"\n"/*   J!            | Integer | uintptr_t, native endian (same with J) */
"\n"/*                 |         | (J! is available since Ruby 2.3.) */
"\n"/*                 |         | */
"\n"/*   s_ s!         | Integer | signed short, native endian */
"\n"/*   i i_ i!       | Integer | signed int, native endian */
"\n"/*   l_ l!         | Integer | signed long, native endian */
"\n"/*   q_ q!         | Integer | signed long long, native endian (ArgumentError */
"\n"/*                 |         | if the platform has no long long type.) */
"\n"/*                 |         | (q_ and q! is available since Ruby 2.1.) */
"\n"/*   j!            | Integer | intptr_t, native endian (same with j) */
"\n"/*                 |         | (j! is available since Ruby 2.3.) */
"\n"/*                 |         | */
"\n"/*   S> s> S!> s!> | Integer | same as the directives without \">\" except */
"\n"/*   L> l> L!> l!> |         | big endian */
"\n"/*   I!> i!>       |         | (available since Ruby 1.9.3) */
"\n"/*   Q> q> Q!> q!> |         | \"S>\" is same as \"n\" */
"\n"/*   J> j> J!> j!> |         | \"L>\" is same as \"N\" */
"\n"/*                 |         | */
"\n"/*   S< s< S!< s!< | Integer | same as the directives without \"<\" except */
"\n"/*   L< l< L!< l!< |         | little endian */
"\n"/*   I!< i!<       |         | (available since Ruby 1.9.3) */
"\n"/*   Q< q< Q!< q!< |         | \"S<\" is same as \"v\" */
"\n"/*   J< j< J!< j!< |         | \"L<\" is same as \"V\" */
"\n"/*                 |         | */
"\n"/*   n             | Integer | 16-bit unsigned, network (big-endian) byte order */
"\n"/*   N             | Integer | 32-bit unsigned, network (big-endian) byte order */
"\n"/*   v             | Integer | 16-bit unsigned, VAX (little-endian) byte order */
"\n"/*   V             | Integer | 32-bit unsigned, VAX (little-endian) byte order */
"\n"/*                 |         | */
"\n"/*   U             | Integer | UTF-8 character */
"\n"/*   w             | Integer | BER-compressed integer */
"\n"/*  */
"\n"/*   Float        | Array   | */
"\n"/*   Directive    | Element | Meaning */
"\n"/*   --------------------------------------------------------------------------- */
"\n"/*   D d          | Float   | double-precision, native format */
"\n"/*   F f          | Float   | single-precision, native format */
"\n"/*   E            | Float   | double-precision, little-endian byte order */
"\n"/*   e            | Float   | single-precision, little-endian byte order */
"\n"/*   G            | Float   | double-precision, network (big-endian) byte order */
"\n"/*   g            | Float   | single-precision, network (big-endian) byte order */
"\n"/*  */
"\n"/*   String       | Array   | */
"\n"/*   Directive    | Element | Meaning */
"\n"/*   --------------------------------------------------------------------------- */
"\n"/*   A            | String  | arbitrary binary string (space padded, count is width) */
"\n"/*   a            | String  | arbitrary binary string (null padded, count is width) */
"\n"/*   Z            | String  | same as ``a'', except that null is added with * */
"\n"/*   B            | String  | bit string (MSB first) */
"\n"/*   b            | String  | bit string (LSB first) */
"\n"/*   H            | String  | hex string (high nibble first) */
"\n"/*   h            | String  | hex string (low nibble first) */
"\n"/*   u            | String  | UU-encoded string */
"\n"/*   M            | String  | quoted printable, MIME encoding (see also RFC2045) */
"\n"/*                |         | (text mode but input must use LF and output LF) */
"\n"/*   m            | String  | base64 encoded string (see RFC 2045) */
"\n"/*                |         | (if count is 0, no line feed are added, see RFC 4648) */
"\n"/*                |         | (count specifies input bytes between each LF, */
"\n"/*                |         | rounded down to nearest multiple of 3) */
"\n"/*   P            | String  | pointer to a structure (fixed-length string) */
"\n"/*   p            | String  | pointer to a null-terminated string */
"\n"/*  */
"\n"/*   Misc.        | Array   | */
"\n"/*   Directive    | Element | Meaning */
"\n"/*   --------------------------------------------------------------------------- */
"\n"/*   @            | ---     | moves to absolute position */
"\n"/*   X            | ---     | back up a byte */
"\n"/*   x            | ---     | null byte */
"  def pack(fmt, buffer: nil)\n"
"    __builtin_pack_pack(fmt, buffer)\n"
"  end\n"
"end\n"
"\n"
"class String\n"
"\n"/* call-seq: */
"\n"/*    str.unpack(format)    ->  anArray */
"\n"/*  */
"\n"/* Decodes <i>str</i> (which may contain binary data) according to the */
"\n"/* format string, returning an array of each value extracted. The */
"\n"/* format string consists of a sequence of single-character directives, */
"\n"/* summarized in the table at the end of this entry. */
"\n"/* Each directive may be followed */
"\n"/* by a number, indicating the number of times to repeat with this */
"\n"/* directive. An asterisk (``<code>*</code>'') will use up all */
"\n"/* remaining elements. The directives <code>sSiIlL</code> may each be */
"\n"/* followed by an underscore (``<code>_</code>'') or */
"\n"/* exclamation mark (``<code>!</code>'') to use the underlying */
"\n"/* platform's native size for the specified type; otherwise, it uses a */
"\n"/* platform-independent consistent size. Spaces are ignored in the */
"\n"/* format string. See also String#unpack1,  Array#pack. */
"\n"/*  */
"\n"/*    \"abc \\0\\0abc \\0\\0\".unpack('A6Z6')   #=> [\"abc\", \"abc \"] */
"\n"/*    \"abc \\0\\0\".unpack('a3a3')           #=> [\"abc\", \" \\000\\000\"] */
"\n"/*    \"abc \\0abc \\0\".unpack('Z*Z*')       #=> [\"abc \", \"abc \"] */
"\n"/*    \"aa\".unpack('b8B8')                 #=> [\"10000110\", \"01100001\"] */
"\n"/*    \"aaa\".unpack('h2H2c')               #=> [\"16\", \"61\", 97] */
"\n"/*    \"\\xfe\\xff\\xfe\\xff\".unpack('sS')     #=> [-2, 65534] */
"\n"/*    \"now=20is\".unpack('M*')             #=> [\"now is\"] */
"\n"/*    \"whole\".unpack('xax2aX2aX1aX2a')    #=> [\"h\", \"e\", \"l\", \"l\", \"o\"] */
"\n"/*  */
"\n"/* This table summarizes the various formats and the Ruby classes */
"\n"/* returned by each. */
"\n"/*  */
"\n"/*  Integer       |         | */
"\n"/*  Directive     | Returns | Meaning */
"\n"/*  ------------------------------------------------------------------ */
"\n"/*  C             | Integer | 8-bit unsigned (unsigned char) */
"\n"/*  S             | Integer | 16-bit unsigned, native endian (uint16_t) */
"\n"/*  L             | Integer | 32-bit unsigned, native endian (uint32_t) */
"\n"/*  Q             | Integer | 64-bit unsigned, native endian (uint64_t) */
"\n"/*  J             | Integer | pointer width unsigned, native endian (uintptr_t) */
"\n"/*                |         | */
"\n"/*  c             | Integer | 8-bit signed (signed char) */
"\n"/*  s             | Integer | 16-bit signed, native endian (int16_t) */
"\n"/*  l             | Integer | 32-bit signed, native endian (int32_t) */
"\n"/*  q             | Integer | 64-bit signed, native endian (int64_t) */
"\n"/*  j             | Integer | pointer width signed, native endian (intptr_t) */
"\n"/*                |         | */
"\n"/*  S_ S!         | Integer | unsigned short, native endian */
"\n"/*  I I_ I!       | Integer | unsigned int, native endian */
"\n"/*  L_ L!         | Integer | unsigned long, native endian */
"\n"/*  Q_ Q!         | Integer | unsigned long long, native endian (ArgumentError */
"\n"/*                |         | if the platform has no long long type.) */
"\n"/*  J!            | Integer | uintptr_t, native endian (same with J) */
"\n"/*                |         | */
"\n"/*  s_ s!         | Integer | signed short, native endian */
"\n"/*  i i_ i!       | Integer | signed int, native endian */
"\n"/*  l_ l!         | Integer | signed long, native endian */
"\n"/*  q_ q!         | Integer | signed long long, native endian (ArgumentError */
"\n"/*                |         | if the platform has no long long type.) */
"\n"/*  j!            | Integer | intptr_t, native endian (same with j) */
"\n"/*                |         | */
"\n"/*  S> s> S!> s!> | Integer | same as the directives without \">\" except */
"\n"/*  L> l> L!> l!> |         | big endian */
"\n"/*  I!> i!>       |         | */
"\n"/*  Q> q> Q!> q!> |         | \"S>\" is same as \"n\" */
"\n"/*  J> j> J!> j!> |         | \"L>\" is same as \"N\" */
"\n"/*                |         | */
"\n"/*  S< s< S!< s!< | Integer | same as the directives without \"<\" except */
"\n"/*  L< l< L!< l!< |         | little endian */
"\n"/*  I!< i!<       |         | */
"\n"/*  Q< q< Q!< q!< |         | \"S<\" is same as \"v\" */
"\n"/*  J< j< J!< j!< |         | \"L<\" is same as \"V\" */
"\n"/*                |         | */
"\n"/*  n             | Integer | 16-bit unsigned, network (big-endian) byte order */
"\n"/*  N             | Integer | 32-bit unsigned, network (big-endian) byte order */
"\n"/*  v             | Integer | 16-bit unsigned, VAX (little-endian) byte order */
"\n"/*  V             | Integer | 32-bit unsigned, VAX (little-endian) byte order */
"\n"/*                |         | */
"\n"/*  U             | Integer | UTF-8 character */
"\n"/*  w             | Integer | BER-compressed integer (see Array.pack) */
"\n"/*  */
"\n"/*  Float        |         | */
"\n"/*  Directive    | Returns | Meaning */
"\n"/*  ----------------------------------------------------------------- */
"\n"/*  D d          | Float   | double-precision, native format */
"\n"/*  F f          | Float   | single-precision, native format */
"\n"/*  E            | Float   | double-precision, little-endian byte order */
"\n"/*  e            | Float   | single-precision, little-endian byte order */
"\n"/*  G            | Float   | double-precision, network (big-endian) byte order */
"\n"/*  g            | Float   | single-precision, network (big-endian) byte order */
"\n"/*  */
"\n"/*  String       |         | */
"\n"/*  Directive    | Returns | Meaning */
"\n"/*  ----------------------------------------------------------------- */
"\n"/*  A            | String  | arbitrary binary string (remove trailing nulls and ASCII spaces) */
"\n"/*  a            | String  | arbitrary binary string */
"\n"/*  Z            | String  | null-terminated string */
"\n"/*  B            | String  | bit string (MSB first) */
"\n"/*  b            | String  | bit string (LSB first) */
"\n"/*  H            | String  | hex string (high nibble first) */
"\n"/*  h            | String  | hex string (low nibble first) */
"\n"/*  u            | String  | UU-encoded string */
"\n"/*  M            | String  | quoted-printable, MIME encoding (see RFC2045) */
"\n"/*  m            | String  | base64 encoded string (RFC 2045) (default) */
"\n"/*               |         | base64 encoded string (RFC 4648) if followed by 0 */
"\n"/*  P            | String  | pointer to a structure (fixed-length string) */
"\n"/*  p            | String  | pointer to a null-terminated string */
"\n"/*  */
"\n"/*  Misc.        |         | */
"\n"/*  Directive    | Returns | Meaning */
"\n"/*  ----------------------------------------------------------------- */
"\n"/*  @            | ---     | skip to the offset given by the length argument */
"\n"/*  X            | ---     | skip backward one byte */
"\n"/*  x            | ---     | skip forward one byte */
"\n"/*  */
"\n"/* HISTORY */
"\n"/*  */
"\n"/* * J, J! j, and j! are available since Ruby 2.3. */
"\n"/* * Q_, Q!, q_, and q! are available since Ruby 2.1. */
"\n"/* * I!<, i!<, I!>, and i!> are available since Ruby 1.9.3. */
"  def unpack(fmt)\n"
"    __builtin_pack_unpack(fmt)\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*    str.unpack1(format)    ->  obj */
"\n"/*  */
"\n"/* Decodes <i>str</i> (which may contain binary data) according to the */
"\n"/* format string, returning the first value extracted. */
"\n"/* See also String#unpack, Array#pack. */
"\n"/*  */
"\n"/* Contrast with String#unpack: */
"\n"/*  */
"\n"/*    \"abc \\0\\0abc \\0\\0\".unpack('A6Z6')   #=> [\"abc\", \"abc \"] */
"\n"/*    \"abc \\0\\0abc \\0\\0\".unpack1('A6Z6')  #=> \"abc\" */
"\n"/*  */
"\n"/* In that case data would be lost but often it's the case that the array */
"\n"/* only holds one value, especially when unpacking binary data. For instance: */
"\n"/*  */
"\n"/* \"\\xff\\x00\\x00\\x00\".unpack(\"l\")         #=>  [255] */
"\n"/* \"\\xff\\x00\\x00\\x00\".unpack1(\"l\")        #=>  255 */
"\n"/*  */
"\n"/* Thus unpack1 is convenient, makes clear the intention and signals */
"\n"/* the expected return value to those reading the code. */
"  def unpack1(fmt)\n"
"    __builtin_pack_unpack1(fmt)\n"
"  end\n"
"end\n"
#line 770 "miniprelude.c"
};

static const char prelude_name4[] = "<internal:trace_point>";
static const struct {
    char L0[447]; /* 1..194 */
    char L194[479]; /* 195..262 */
    char L262[490]; /* 263..331 */
    char L331[215]; /* 332..349 */
} prelude_code4 = {
#line 1 "trace_point.rb"
"\n"/* loaded from vm_trace.c */
"\n"
"\n"/* Document-class: TracePoint */
"\n"/*  */
"\n"/* A class that provides the functionality of Kernel#set_trace_func in a */
"\n"/* nice Object-Oriented API. */
"\n"/*  */
"\n"/* == Example */
"\n"/*  */
"\n"/* We can use TracePoint to gather information specifically for exceptions: */
"\n"/*  */
"\n"/*     trace = TracePoint.new(:raise) do |tp| */
"\n"/* \011p [tp.lineno, tp.event, tp.raised_exception] */
"\n"/*     end */
"\n"/*     #=> #<TracePoint:disabled> */
"\n"/*  */
"\n"/*     trace.enable */
"\n"/*     #=> false */
"\n"/*  */
"\n"/*     0 / 0 */
"\n"/*     #=> [5, :raise, #<ZeroDivisionError: divided by 0>] */
"\n"/*  */
"\n"/* == Events */
"\n"/*  */
"\n"/* If you don't specify the type of events you want to listen for, */
"\n"/* TracePoint will include all available events. */
"\n"/*  */
"\n"/* *Note* do not depend on current event set, as this list is subject to */
"\n"/* change. Instead, it is recommended you specify the type of events you */
"\n"/* want to use. */
"\n"/*  */
"\n"/* To filter what is traced, you can pass any of the following as +events+: */
"\n"/*  */
"\n"/* +:line+:: execute code on a new line */
"\n"/* +:class+:: start a class or module definition */
"\n"/* +:end+:: finish a class or module definition */
"\n"/* +:call+:: call a Ruby method */
"\n"/* +:return+:: return from a Ruby method */
"\n"/* +:c_call+:: call a C-language routine */
"\n"/* +:c_return+:: return from a C-language routine */
"\n"/* +:raise+:: raise an exception */
"\n"/* +:b_call+:: event hook at block entry */
"\n"/* +:b_return+:: event hook at block ending */
"\n"/* +:thread_begin+:: event hook at thread beginning */
"\n"/* +:thread_end+:: event hook at thread ending */
"\n"/* +:fiber_switch+:: event hook at fiber switch */
"\n"/* +:script_compiled+:: new Ruby code compiled (with +eval+, +load+ or +require+) */
"\n"/*  */
"class TracePoint\n"
"\n"/* call-seq: */
"\n"/* TracePoint.new(*events) { |obj| block }\011    -> obj */
"\n"/*  */
"\n"/* Returns a new TracePoint object, not enabled by default. */
"\n"/*  */
"\n"/* Next, in order to activate the trace, you must use TracePoint#enable */
"\n"/*  */
"\n"/* trace = TracePoint.new(:call) do |tp| */
"\n"/*     p [tp.lineno, tp.defined_class, tp.method_id, tp.event] */
"\n"/* end */
"\n"/* #=> #<TracePoint:disabled> */
"\n"/*  */
"\n"/* trace.enable */
"\n"/* #=> false */
"\n"/*  */
"\n"/* puts \"Hello, TracePoint!\" */
"\n"/* # ... */
"\n"/* # [48, IRB::Notifier::AbstractNotifier, :printf, :call] */
"\n"/* # ... */
"\n"/*  */
"\n"/* When you want to deactivate the trace, you must use TracePoint#disable */
"\n"/*  */
"\n"/* trace.disable */
"\n"/*  */
"\n"/* See TracePoint@Events for possible events and more information. */
"\n"/*  */
"\n"/* A block must be given, otherwise an ArgumentError is raised. */
"\n"/*  */
"\n"/* If the trace method isn't included in the given events filter, a */
"\n"/* RuntimeError is raised. */
"\n"/*  */
"\n"/* TracePoint.trace(:line) do |tp| */
"\n"/*     p tp.raised_exception */
"\n"/* end */
"\n"/* #=> RuntimeError: 'raised_exception' not supported by this event */
"\n"/*  */
"\n"/* If the trace method is called outside block, a RuntimeError is raised. */
"\n"/*  */
"\n"/*      TracePoint.trace(:line) do |tp| */
"\n"/*        $tp = tp */
"\n"/*      end */
"\n"/*      $tp.lineno #=> access from outside (RuntimeError) */
"\n"/*  */
"\n"/* Access from other threads is also forbidden. */
"\n"/*  */
"  def self.new(*events)\n"
"    __builtin_tracepoint_new_s(events)\n"
"  end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*    trace.inspect  -> string */
"\n"/*  */
"\n"/*  Return a string containing a human-readable TracePoint */
"\n"/*  status. */
"  def inspect\n"
"    __builtin_tracepoint_inspect\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/* TracePoint.stat -> obj */
"\n"/*  */
"\n"/*  Returns internal information of TracePoint. */
"\n"/*  */
"\n"/*  The contents of the returned value are implementation specific. */
"\n"/*  It may be changed in future. */
"\n"/*  */
"\n"/*  This method is only for debugging TracePoint itself. */
"  def self.stat\n"
"    __builtin_tracepoint_stat_s\n"
"  end\n"
"\n"
"\n"/* Document-method: trace */
"\n"/*  */
"\n"/* call-seq: */
"\n"/* TracePoint.trace(*events) { |obj| block }\011-> obj */
"\n"/*  */
"\n"/*  A convenience method for TracePoint.new, that activates the trace */
"\n"/*  automatically. */
"\n"/*  */
"\n"/*     trace = TracePoint.trace(:call) { |tp| [tp.lineno, tp.event] } */
"\n"/*     #=> #<TracePoint:enabled> */
"\n"/*  */
"\n"/*     trace.enabled? #=> true */
"\n"/*  */
"  def self.trace(*events)\n"
"    __builtin_tracepoint_trace_s(events)\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*    trace.enable(target: nil, target_line: nil, target_thread: nil)    -> true or false */
"\n"/*    trace.enable(target: nil, target_line: nil, target_thread: nil) { block }  -> obj */
"\n"/*  */
"\n"/* Activates the trace. */
"\n"/*  */
"\n"/* Returns +true+ if trace was enabled. */
"\n"/* Returns +false+ if trace was disabled. */
"\n"/*  */
"\n"/*   trace.enabled?  #=> false */
"\n"/*   trace.enable    #=> false (previous state) */
"\n"/*                   #   trace is enabled */
"\n"/*   trace.enabled?  #=> true */
"\n"/*   trace.enable    #=> true (previous state) */
"\n"/*                   #   trace is still enabled */
"\n"/*  */
"\n"/* If a block is given, the trace will only be enabled within the scope of the */
"\n"/* block. */
"\n"/*  */
"\n"/*    trace.enabled? */
"\n"/*    #=> false */
"\n"/*  */
"\n"/*    trace.enable do */
"\n"/*      trace.enabled? */
"\n"/*      # only enabled for this block */
"\n"/*    end */
"\n"/*  */
"\n"/*    trace.enabled? */
"\n"/*    #=> false */
"\n"/*  */
"\n"/* +target+, +target_line+ and +target_thread+ parameters are used to */
"\n"/* limit tracing only to specified code objects. +target+ should be a */
"\n"/* code object for which RubyVM::InstructionSequence.of will return */
"\n"/* an instruction sequence. */
"\n"/*  */
"\n"/*    t = TracePoint.new(:line) { |tp| p tp } */
"\n"/*  */
"\n"/*    def m1 */
"\n"/*      p 1 */
"\n"/*    end */
"\n"/*  */
"\n"/*    def m2 */
"\n"/*      p 2 */
"\n"/*    end */
"\n"/*  */
"\n"/*    t.enable(target: method(:m1)) */
"\n"/*  */
"\n"/*    m1 */
"\n"/*    # prints #<TracePoint:line@test.rb:5 in `m1'> */
"\n"/*    m2 */
"\n"/*    # prints nothing */
"\n"/*  */
"\n"/* Note: You cannot access event hooks within the +enable+ block. */
"\n"/*  */
"\n"/*    trace.enable { p tp.lineno } */
"\n"/*    #=> RuntimeError: access from outside */
"\n"/*  */
,
#line 195 "trace_point.rb"
"  def enable(target: nil, target_line: nil, target_thread: nil)\n"
"    __builtin_tracepoint_enable_m(target, target_line, target_thread)\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/* trace.disable\011\011-> true or false */
"\n"/* trace.disable { block } -> obj */
"\n"/*  */
"\n"/* Deactivates the trace */
"\n"/*  */
"\n"/* Return true if trace was enabled. */
"\n"/* Return false if trace was disabled. */
"\n"/*  */
"\n"/* trace.enabled?\011#=> true */
"\n"/* trace.disable\011#=> true (previous status) */
"\n"/* trace.enabled?\011#=> false */
"\n"/* trace.disable\011#=> false */
"\n"/*  */
"\n"/* If a block is given, the trace will only be disable within the scope of the */
"\n"/* block. */
"\n"/*  */
"\n"/* trace.enabled? */
"\n"/* #=> true */
"\n"/*  */
"\n"/* trace.disable do */
"\n"/*     trace.enabled? */
"\n"/*     # only disabled for this block */
"\n"/* end */
"\n"/*  */
"\n"/* trace.enabled? */
"\n"/* #=> true */
"\n"/*  */
"\n"/* Note: You cannot access event hooks within the block. */
"\n"/*  */
"\n"/* trace.disable { p tp.lineno } */
"\n"/* #=> RuntimeError: access from outside */
"  def disable\n"
"    __builtin_tracepoint_disable_m\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/* trace.enabled?\011    -> true or false */
"\n"/*  */
"\n"/* The current status of the trace */
"  def enabled?\n"
"    __builtin_tracepoint_enabled_p\n"
"  end\n"
"\n"
"\n"/* Type of event */
"\n"/*  */
"\n"/* See TracePoint@Events for more information. */
"  def event\n"
"    __builtin_tracepoint_attr_event\n"
"  end\n"
"\n"
"\n"/* Line number of the event */
"  def lineno\n"
"    __builtin_tracepoint_attr_lineno\n"
"  end\n"
"\n"
"\n"/* Path of the file being run */
"  def path\n"
"    __builtin_tracepoint_attr_path\n"
"  end\n"
"\n"
"\n"/* Return the parameters definition of the method or block that the */
"\n"/* current hook belongs to. Format is the same as for Method#parameters */
"  def parameters\n"
,
#line 263 "trace_point.rb"
"    __builtin_tracepoint_attr_parameters\n"
"  end\n"
"\n"
"\n"/* Return the name at the definition of the method being called */
"  def method_id\n"
"    __builtin_tracepoint_attr_method_id\n"
"  end\n"
"\n"
"\n"/* Return the called name of the method being called */
"  def callee_id\n"
"    __builtin_tracepoint_attr_callee_id\n"
"  end\n"
"\n"
"\n"/* Return class or module of the method being called. */
"\n"/*  */
"\n"/* class C; def foo; end; end */
"\n"/* \011trace = TracePoint.new(:call) do |tp| */
"\n"/* \011  p tp.defined_class #=> C */
"\n"/* \011end.enable do */
"\n"/* \011  C.new.foo */
"\n"/* \011end */
"\n"/*  */
"\n"/* If method is defined by a module, then that module is returned. */
"\n"/*  */
"\n"/* module M; def foo; end; end */
"\n"/* \011class C; include M; end; */
"\n"/* \011trace = TracePoint.new(:call) do |tp| */
"\n"/* \011  p tp.defined_class #=> M */
"\n"/* \011end.enable do */
"\n"/* \011  C.new.foo */
"\n"/* \011end */
"\n"/*  */
"\n"/* <b>Note:</b> #defined_class returns singleton class. */
"\n"/*  */
"\n"/* 6th block parameter of Kernel#set_trace_func passes original class */
"\n"/* of attached by singleton class. */
"\n"/*  */
"\n"/* <b>This is a difference between Kernel#set_trace_func and TracePoint.</b> */
"\n"/*  */
"\n"/* class C; def self.foo; end; end */
"\n"/* \011trace = TracePoint.new(:call) do |tp| */
"\n"/* \011  p tp.defined_class #=> #<Class:C> */
"\n"/* \011end.enable do */
"\n"/* \011  C.foo */
"\n"/* \011end */
"  def defined_class\n"
"    __builtin_tracepoint_attr_defined_class\n"
"  end\n"
"\n"
"\n"/* Return the generated binding object from event */
"  def binding\n"
"    __builtin_tracepoint_attr_binding\n"
"  end\n"
"\n"
"\n"/* Return the trace object during event */
"\n"/*  */
"\n"/* Same as TracePoint#binding: */
"\n"/* trace.binding.eval('self') */
"  def self\n"
"    __builtin_tracepoint_attr_self\n"
"  end\n"
"\n"
"\n"/*  Return value from +:return+, +c_return+, and +b_return+ event */
"  def return_value\n"
"    __builtin_tracepoint_attr_return_value\n"
"  end\n"
"\n"
"\n"/* Value from exception raised on the +:raise+ event */
"  def raised_exception\n"
,
#line 332 "trace_point.rb"
"    __builtin_tracepoint_attr_raised_exception\n"
"  end\n"
"\n"
"\n"/* Compiled source code (String) on *eval methods on the +:script_compiled+ event. */
"\n"/* If loaded from a file, it will return nil. */
"  def eval_script\n"
"    __builtin_tracepoint_attr_eval_script\n"
"  end\n"
"\n"
"\n"/* Compiled instruction sequence represented by a RubyVM::InstructionSequence instance */
"\n"/* on the +:script_compiled+ event. */
"\n"/*  */
"\n"/* Note that this method is MRI specific. */
"  def instruction_sequence\n"
"    __builtin_tracepoint_attr_instruction_sequence\n"
"  end\n"
"end\n"
#line 1135 "miniprelude.c"
};

static const char prelude_name5[] = "<internal:warning>";
static const struct {
    char L0[152]; /* 1..46 */
} prelude_code5 = {
#line 1 "warning.rb"
"\n"/* encoding: utf-8 */
"\n"/* fronzen-string-literal: true */
"\n"
"module Kernel\n"
"  module_function\n"
"\n"
"\n"/* call-seq: */
"\n"/*    warn(*msgs, uplevel: nil)   -> nil */
"\n"/*  */
"\n"/* If warnings have been disabled (for example with the */
"\n"/* <code>-W0</code> flag), does nothing.  Otherwise, */
"\n"/* converts each of the messages to strings, appends a newline */
"\n"/* character to the string if the string does not end in a newline, */
"\n"/* and calls Warning.warn with the string. */
"\n"/*  */
"\n"/*    warn(\"warning 1\", \"warning 2\") */
"\n"/*  */
"\n"/*  <em>produces:</em> */
"\n"/*  */
"\n"/*    warning 1 */
"\n"/*    warning 2 */
"\n"/*  */
"\n"/* If the <code>uplevel</code> keyword argument is given, the string will */
"\n"/* be prepended with information for the given caller frame in */
"\n"/* the same format used by the <code>rb_warn</code> C function. */
"\n"/*  */
"\n"/*    # In baz.rb */
"\n"/*    def foo */
"\n"/*      warn(\"invalid call to foo\", uplevel: 1) */
"\n"/*    end */
"\n"/*  */
"\n"/*    def bar */
"\n"/*      foo */
"\n"/*    end */
"\n"/*  */
"\n"/*    bar */
"\n"/*  */
"\n"/*  <em>produces:</em> */
"\n"/*  */
"\n"/*    baz.rb:6: warning: invalid call to foo */
"\n"/*  */
"  def warn(*msgs, uplevel: nil)\n"
"    __builtin_rb_warn_m(msgs, uplevel)\n"
"  end\n"
"end\n"
#line 1188 "miniprelude.c"
};

static const char prelude_name6[] = "<internal:prelude>";
static const struct {
    char L0[415]; /* 1..38 */
} prelude_code6 = {
#line 1 "prelude.rb"
"class << Thread\n"
"\n"/* call-seq: */
"\n"/*    Thread.exclusive { block }   -> obj */
"\n"/*  */
"\n"/* Wraps the block in a single, VM-global Mutex.synchronize, returning the */
"\n"/* value of the block. A thread executing inside the exclusive section will */
"\n"/* only block other threads which also use the Thread.exclusive mechanism. */
"  def exclusive(&block) end if false\n"
"  mutex = Mutex.new\n"/* :nodoc: */
"  define_method(:exclusive) do |&block|\n"
"    warn \"Thread.exclusive is deprecated, use Thread::Mutex\", uplevel: 1\n"
"    mutex.synchronize(&block)\n"
"  end\n"
"end\n"
"\n"
"class Binding\n"
"\n"/* :nodoc: */
"  def irb\n"
"    require 'irb'\n"
"    irb\n"
"  end\n"
"\n"
"\n"/* suppress redefinition warning */
"  alias irb irb\n"/* :nodoc: */
"end\n"
"\n"
"module Kernel\n"
"  def pp(*objs)\n"
"    require 'pp'\n"
"    pp(*objs)\n"
"  end\n"
"\n"
"\n"/* suppress redefinition warning */
"  alias pp pp\n"/* :nodoc: */
"\n"
"  private :pp\n"
"end\n"
#line 1233 "miniprelude.c"
};

static const char prelude_name7[] = "<internal:gem_prelude>";
static const struct {
    char L0[86]; /* 1..3 */
} prelude_code7 = {
#line 1 "gem_prelude.rb"
"require 'rubygems.rb' if defined?(Gem)\n"
"require 'did_you_mean' if defined?(DidYouMean)\n"
#line 1243 "miniprelude.c"
};

#define PRELUDE_NAME(n) rb_usascii_str_new_static(prelude_name##n, sizeof(prelude_name##n)-1)
#define PRELUDE_CODE(n) rb_utf8_str_new_static(prelude_code##n.L0, sizeof(prelude_code##n))

static rb_ast_t *
prelude_ast(VALUE name, VALUE code, int line)
{
    rb_ast_t *ast = rb_parser_compile_string_path(rb_parser_new(), name, code, line);
    if (!ast->body.root) {
	rb_ast_dispose(ast);
	rb_exc_raise(rb_errinfo());
    }
    return ast;
}

#define PRELUDE_AST(n, name_str) \
    (((sizeof(prelude_name##n) - prefix_len - 2) == namelen) && \
     (strncmp(prelude_name##n + prefix_len, feature_name, namelen) == 0) ? \
     prelude_ast((name_str) = PRELUDE_NAME(n), PRELUDE_CODE(n), 1) : 0)

rb_ast_t *
rb_builtin_ast(const char *feature_name, VALUE *name_str)
{
    const size_t prefix_len = rb_strlen_lit("<internal:");
    size_t namelen = strlen(feature_name);
    rb_ast_t *ast = 0;

    if ((ast = PRELUDE_AST(0, *name_str)) != 0) return ast;
    if ((ast = PRELUDE_AST(1, *name_str)) != 0) return ast;
    if ((ast = PRELUDE_AST(2, *name_str)) != 0) return ast;
    if ((ast = PRELUDE_AST(3, *name_str)) != 0) return ast;
    if ((ast = PRELUDE_AST(4, *name_str)) != 0) return ast;
    if ((ast = PRELUDE_AST(5, *name_str)) != 0) return ast;
    if ((ast = PRELUDE_AST(6, *name_str)) != 0) return ast;
    if ((ast = PRELUDE_AST(7, *name_str)) != 0) return ast;
    return ast;
}

void
Init_prelude(void)
{
}
